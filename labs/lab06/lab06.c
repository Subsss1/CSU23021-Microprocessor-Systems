#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "pico/stdlib.h"
#include "pico/float.h"     // Required for using single-precision variables.
#include "pico/double.h"    // Required for using double-precision variables.
#include "pico/multicore.h" // Required for using multiple cores on the RP2040.


/**
 * @brief This function acts as the main entry-point for core #1.
 *        A function pointer is passed in via the FIFO with one
 *        incoming int32_t used as a parameter. The function will
 *        provide an int32_t return value by pushing it back on 
 *        the FIFO, which also indicates that the result is ready.
 */
void core1_entry() {
    while (1) {
        // 
        int32_t (*func)() = (int32_t(*)()) multicore_fifo_pop_blocking();
        int32_t p = multicore_fifo_pop_blocking();
        int32_t result = (*func)(p);
        multicore_fifo_push_blocking(result);
    }
}

float singlePrecisionPI(int precision){                                                             //using float to calculate the number in single precision method                          
    float pi = 1;                                                                                   //initialize the first number in the wallis product      
    float x = 1;                                                                                    //initialize pi and update it in the following loop       
    for(float i = 2; i <= precision; i+=2){                                                         //loop 100000 times and get a pi that generated by wallis product                              
        pi = pi * ( (i*i) / ( x * (x + 2) ) );                                                      //2 2 4 4 6 6 8 8                                   
        x += 2;                                                                                     //1 3 3 5 5 7 7 9  
    }
    pi *= 2;
    return pi;
}


double doublePrecisionPI(int precision){                                                            //using double to calculate the number in double precision method                                   
    double pi = 1;                                                                                  //initialize the first number in the wallis product           
    double x = 1;                                                                                   //initialize pi and update it in the following loop           
    for(double i = 2; i <= precision; i+=2){                                                        //loop 100000 times and get a pi that generated by wallis product                                       
        pi = pi * ( (i*i) / ( x * (x + 2) ) );                                                      //2 2 4 4 6 6 8 8                                       
        x += 2;                                                                                     //1 3 3 5 5 7 7 9       
    }
    pi *= 2;
    return pi;
}


// Main code entry point for core0.
int main() {

    const int    ITER_MAX   = 100000;

    stdio_init_all();

    int startingTime = time_us_32();                                                               //Record the starting stage of single-core starting stage

    int startSinglePrecision = time_us_32();                                                       //Take snapshot of the starting stage of timer and store                                                                      
                                
    singlePrecisionPI(ITER_MAX);                                                                   //Run the single-precision Wallis approximation
                                
    int endSinglePrecision = time_us_32();                                                         //Take snapshot of the ending stage of timer and store
                                
                                
    int doublePrecisionSnapshot = time_us_32();                                                    //Take snapshot of the starting stage of timer and store

    doublePrecisionPI(ITER_MAX);                                                                   //Run the double-precision Wallis approximation

    int endDoublePrecision = time_us_32();                                                         //Take snapshot of the ending stage of timer and store

    int endingTime = time_us_32();                                                                 //Record the ending stage of single-core starting stage

    int singleTime = endingTime - startingTime;
    printf("Running time of single-core: %lld\n",singleTime);

    int singlePrecisionTime = endSinglePrecision - startSinglePrecision;
    printf("Running time of single-precision Wallis on single-core: %lld\n",singlePrecisionTime); 

    int doublePrecisionTime = endDoublePrecision - doublePrecisionSnapshot;  
    printf("Running time of double-precision Wallis on single-core: %lld\n",doublePrecisionTime); 
      

    // Code for parallel run goes hereâ€¦

    multicore_launch_core1(core1_entry);

    int startingTimeMulti = time_us_32();                                                          //Take a snapshot of multicore starting time and store

    int startSinglePrecisionMulti = time_us_32();                                                  //Take a snapshot of the first core starting time and store
    multicore_fifo_push_blocking((uintptr_t) &singlePrecisionPI);
    multicore_fifo_push_blocking(ITER_MAX);                                                        //Run the single-precision Wallis approximation on one core
    int startDoublePrecisionMulti = time_us_32();                                                  //Take a snapshot of the second core starting time and store
    doublePrecisionPI(ITER_MAX);                                                                   //Run the double-precision Wallis approximation on the other core
    int endDoublePrecisionMulti = time_us_32();                                                    //Take a snapshot of the second core ending time and store
    int tmp = multicore_fifo_pop_blocking();
    int endSinglePresicionMulti = time_us_32();                                                    //Take a snapshot of the first core ending time and store

    int endingTimeMulti = time_us_32();                                                            //Take a snapshot of multicore ending time and store


    int multiTime = endingTimeMulti - startingTimeMulti;
    printf("Running time of multicore: %lld\n",multiTime);

    int singlePrecisionTimeMulti = endSinglePresicionMulti - startSinglePrecisionMulti;
    printf("Running time of single-precision Wallis on multicore: %lld\n",singlePrecisionTimeMulti); 

    int doublePrecisionTimeMulti = endDoublePrecisionMulti - startDoublePrecisionMulti;   
    printf("Running time of double-precision Wallis on multicore: %lld\n",doublePrecisionTimeMulti); 
            

    return 0;
}
